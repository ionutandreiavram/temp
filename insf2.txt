Great goal — making sure your parser is reliable across Xilinx BSDL files is very important, because even though Xilinx tries to keep the format consistent, there are still small differences between families (Spartan-6, Artix-7, Kintex-7, Virtex-7, UltraScale, Versal, …), packages, and even between older vs newer tools that generated the BSDL.
Here are the most common variations you should test your parser against (all Xilinx-specific patterns):







































































#Variation typeTypical in which families / yearsWhat to check / what breaks weak parsers1control vs controlrAlmost all since Virtex-4 / Spartan-3Econtrolr = reversed polarity (1 = disable)2output2 (no tri-state) vs output3Configuration pins, dedicated outputsNo ccell / disval / disrslt fields3bidir function (instead of output3+input)Very old BSDLs (pre-Virtex-5 sometimes)Single cell for bidirectional (rare in modern Xilinx)4internal cells with * portAll modern devicesMust skip or handle gracefully (not crash on *)5OBSERVE_ONLY / AC_1 / AC_7 cellsTransceivers (GTP/GTX/GTH/GTY/GTM)Different cell types, no control/output cells6Comments after cell ( -- comment )Almost every Xilinx BSDL-- PAD177, -- CCLK_0, etc. — make sure regex ignores them7Very long lines / broken with &All large devicesYour current block[:end_index] approach is fragile8Missing BOUNDARY_LENGTH attributeVery rare, but happens in hand-editedShould fall back to max(cell_number) + 19Extra spaces, tabs, different quotingGenerated by different versions"IO_xx" vs IO_xx vs "*"10Multiple sections / weird formattingPost-config modified BSDLsShould not crash if finds multiple BOUNDARY_REGISTER
Quick Recommendations to Make Your Parser More Robust
Here are concrete improvements / tests you can do right now:
1. Improve block extraction (very important for large files)
Your current code cuts at first ; — but Xilinx BSDLs sometimes have trailing attributes after the boundary register. Better approach:
Python# Find start
start_match = re.search(
    r'attribute\s+BOUNDARY_REGISTER\s+of\s+.*?\s+is\s*',
    content, re.IGNORECASE | re.DOTALL
)

if not start_match:
    raise ValueError("No BOUNDARY_REGISTER found")

# Take everything after "is" until we find a line with standalone ;
remaining = content[start_match.end():]

# Collect lines until we see a line that is essentially just ;
lines = []
for line in remaining.splitlines():
    cleaned = line.strip()
    if cleaned == ';' or cleaned.startswith(';'):
        break
    if '--' in cleaned:
        cleaned = cleaned.split('--')[0].strip()
    if cleaned:
        lines.append(cleaned)

block = ' '.join(lines)  # now one long string without newlines/comments
2. Stronger cell regex (handles all common Xilinx patterns)
Use this more permissive regex:
Pythoncell_pattern = re.compile(
    r'(\d+)\s*\(\s*([^,]+?)\s*,\s*([^,]+?)\s*,\s*([^,]+?)\s*'
    r'(?:,\s*([^,]+?))?\s*(?:,\s*([^,]+?))?\s*(?:,\s*([^,]+?))?\s*(?:,\s*([^,]+?))?'
    r'\s*\)\s*(?:,\s*)?',
    re.IGNORECASE
)
Then in the loop:
Pythonfor match in cell_pattern.finditer(block):
    groups = match.groups()
    num = groups[0]
    cell_type = groups[1].strip()
    port = groups[2].strip().strip('"')
    func = groups[3].strip()

    safe = ctrl = disval = disres = None
    if len(groups) > 4 and groups[4]:
        safe = groups[4].strip()
    if len(groups) > 5 and groups[5]:
        ctrl = groups[5].strip()
    if len(groups) > 6 and groups[6]:
        disval = groups[6].strip()
    if len(groups) > 7 and groups[7]:
        disres = groups[7].strip()

    # Now create cell object...
3. Quick Tests You Can Run Today
Download these real Xilinx BSDL files (publicly available from Xilinx/AMD site or GitHub mirrors):

Small one: xc7a35tftg256 (Artix-7)
Medium: xc7k325tffg900 (Kintex-7)
Large transceiver-heavy: xc7vh580t (the one you just sent)
Old one: xc6slx9 (Spartan-6)
UltraScale: xcku040 (if you can find it)

Then run your parser on each and check:

Is boundary_len correct?
Do you find all ports that appear in the port (...) list and have output3 or bidir?
Do control cells point to the correct previous cell number?
Are there any cells where ctrl_cell is None but function is output3? (should not happen in modern Xilinx)

4. Mini validation checklist after parsing
You can add something like this at the end of parsing for quick sanity check:
Pythondef validate_parsed_bsdl(bsdl):
    cells = bsdl.boundary_register.cells
    print(f"Total cells: {len(cells)}")
    print(f"Reported length: {bsdl.boundary_len}")

    output3_count = sum(1 for c in cells if c.function == "output3")
    controlr_count = sum(1 for c in cells if c.cell_type == "BC_2" and c.function == "controlr")
    input_count = sum(1 for c in cells if c.function == "input")

    print(f"output3 cells:   {output3_count}")
    print(f"controlr cells:  {controlr_count}")
    print(f"input cells:     {input_count}")

    # Rough heuristic: in modern Xilinx, bidirectional pins ≈ output3 ≈ controlr
    if abs(output3_count - controlr_count) > 10:
        print("Warning: suspicious difference between output3 and controlr count")
If you want, paste the output of this validation for 2–3 different BSDL files and I can tell you immediately whether it looks healthy or something is broken.
Let me know how it goes or if you want me to help tune the regex / block extraction further.